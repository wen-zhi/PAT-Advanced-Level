
* [1032 Sharing](#1032-sharing)
* [1033 To Fill or Not to Fill](#1033-to-fill-or-not-to-fill)
* [1034 Head of a Gang](#1034-head-of-a-gang)
* [1038 Recover the Smallest Number](#1038-recover-the-smallest-number)
* [1040 Longest Symmetric String](#1040-longest-symmetric-string)
* [1043 Is It a Binary Search Tree](#1043-is-it-a-binary-search-tree)
* [1045 Favorite Color Stripe](#1045-favorite-color-stripe)

## 1032 Sharing

将**链表 A** 的每个结点均标记为**已访问**，那么在遍历**链表 B** 时遇到的第一个**已访问过**的节点就是它们的第一个共同结点。

## 1033 To Fill or Not to Fill

记当前加油站所能行至的最大距离为 `max_dist`，那么：
1. 在 `max_dist` 范围内找到比它便宜的作为下一个加油站
2. 如果没有比它便宜的，则选择离 `max_dist` 最近的作为下一个加油站

## 1034 Head of a Gang

虽然看起来像是一个有向图，但实际上它是一个无向图，此时一条边的权重等于双向边之和：
```
        有向图                       无向图
    AAA -> BBB 10    --等价于->   AAA - BBB 30        
    BBB -> AAA 20       
```

因此该问题等价于找到无向图中的连通分量问题。使用 BFS 或者 DFS 都可以完成任务。

## 1038 Recover the Smallest Number

将数字片段组合起来实际上是一个排序问题。排序问题的核心是什么？

**谁前谁后**。

C/C++ 中的**比较函数**就是用来让我们告诉 C/C++ 是参数一放在参数二之后还是参数二放在参数一之后。

同样的，当将数字片段组成一个数字时，`32` 与 `321` 谁前谁后？

比较 `32321` 与 `32132` 即可知道答案（字符串相加很便捷）。

因此通过在比较函数中定义两个片段的**谁前谁后**就能决定所有片段的排列顺序。

## 1040 Longest Symmetric String

最简单的方法莫过于暴力搜索，但其时间复杂度为 O(N^2)。如何改善时间复杂度？

**充分利用已经计算过的信息。**

对称子串有这样一个特点，即**如果一个子串是对称的，那么在其两端再各增加一个相同的字符，那么得到的子串依然是对称的**。利用该规则，我们可以以**单个字符**以及**两个字符**的对称子串为**初始对称子串**，逐渐增长对称子串的长度，最终分别找到长度分别为**奇数**和**偶数**的最长对称子串。

## 1043 Is It a Binary Search Tree

不难发现，对于二叉搜索树，仅依靠其先序遍历便可以重建该树。重建树的过程是一个递归的创建子树的过程，因此可以直接在该过程中记录后序遍历的结果。

如果给出的序列并非二叉搜索树的先序遍历结果，那么得到的后序遍历就不会是完整的 (结点数量小于 N)。

## 1045 Favorite Color Stripe

去掉干扰信息 (i.e. 不喜欢的颜色) 后，便等价于求一个序列中非递减子序列的最大长度问题。可以观察到第 `i` 个位置的最大长度由其前 `i - 1` 个位置的最大长度决定：
```
# L[i] 表示到第 i 个位置时的最大长度。
L[i] = max(L[0] + 1,
           L[1] + 1,
           L[2] + 1,
              ...
           L[i-1] + 1)
```
也就是说，`L[i]` 可被分解为若干子问题。因此从最小的子问题出发，便可逐渐求解至 `L[i]`：
```
for j = 1,2,...,n:
    L[i] = 1 + max({L[i]: i < j})
```
这种从最小子问题自底向上逐渐扩大至目标问题的过程被称作为**动态规划**。
